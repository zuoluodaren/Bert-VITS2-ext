cat exchanges/aster.py 
[?2004l"""
Aster exchange client implementation.
"""

import os
import asyncio
import json
import time
import hmac
import hashlib
from decimal import Decimal
from typing import Dict, Any, List, Optional, Tuple
from urllib.parse import urlencode
import aiohttp
import websockets
import sys

from .base import BaseExchangeClient, OrderResult, OrderInfo, query_retry, normalize_symbol, ExchangeSymbolError
from helpers.logger import TradingLogger


class AsterWebSocketManager:
    """WebSocket manager for Aster order updates."""

    def __init__(self, config: Dict[str, Any], api_key: str, secret_key: str, order_update_callback):
        self.api_key = api_key
        self.secret_key = secret_key
        self.order_update_callback = order_update_callback
        self.websocket = None
        self.running = False
        self.base_url = "https://fapi.asterdex.com"
        self.ws_url = "wss://fstream.asterdex.com"
        self.listen_key = None
        self.logger = None
        self._keepalive_task = None
        self._last_ping_time = None
        self.config = config

    def _generate_signature(self, params: Dict[str, Any]) -> str:
        """Generate HMAC SHA256 signature for Aster API authentication."""
        # Use urlencode to properly format the query string
        query_string = urlencode(params)

        # Generate HMAC SHA256 signature
        signature = hmac.new(
            self.secret_key.encode('utf-8'),
            query_string.encode('utf-8'),
            hashlib.sha256
        ).hexdigest()

        return signature

    async def _get_listen_key(self) -> str:
        """Get listen key for user data stream."""
        params = {
            'timestamp': int(time.time() * 1000)
        }
        signature = self._generate_signature(params)
        params['signature'] = signature

        headers = {
            'X-MBX-APIKEY': self.api_key,
            'Content-Type': 'application/x-www-form-urlencoded'
        }

        async with aiohttp.ClientSession() as session:
            async with session.post(
                'https://fapi.asterdex.com/fapi/v1/listenKey',
                headers=headers,
                data=params
            ) as response:
                if response.status == 200:
                    result = await response.json()
                    return result.get('listenKey')
                else:
                    raise Exception(f"Failed to get listen key: {response.status}")

    async def _keepalive_listen_key(self) -> bool:
        """Keep alive the listen key to prevent timeout."""
        try:
            if not self.listen_key:
                return False

            params = {
                'timestamp': int(time.time() * 1000)
            }
            signature = self._generate_signature(params)
            params['signature'] = signature

            headers = {
                'X-MBX-APIKEY': self.api_key,
                'Content-Type': 'application/x-www-form-urlencoded'
            }

            async with aiohttp.ClientSession() as session:
                async with session.put(
                    f"{self.base_url}/fapi/v1/listenKey",
                    headers=headers,
                    data=params
                ) as response:
                    if response.status == 200:
                        if self.logger:
                            self.logger.log("Listen key keepalive successful", "DEBUG")
                        return True
                    else:
                        if self.logger:
                            self.logger.log(f"Failed to keepalive listen key: {response.status}", "WARNING")
                        return False
        except Exception as e:
            if self.logger:
                self.logger.log(f"Error keeping alive listen key: {e}", "ERROR")
            return False

    async def _check_connection_health(self) -> bool:
        """Check if the WebSocket connection is healthy based on ping timing."""
        if not self._last_ping_time:
            return True  # No pings received yet, assume healthy

        # Check if we haven't received a ping in the last 10 minutes
        # (server sends pings every 5 minutes, so 10 minutes indicates a problem)
        time_since_last_ping = time.time() - self._last_ping_time
        if time_since_last_ping > 10 * 60:  # 10 minutes
            if self.logger:
                self.logger.log(
                    f"No ping received for {time_since_last_ping/60:.1f} minutes, "
                    "connection may be unhealthy", "WARNING"
                )
            return False

        return True

    async def _start_keepalive_task(self):
        """Start the keepalive task to extend listen key validity and monitor connection health."""
        while self.running:
            try:
                # Check connection health every 5 minutes
                await asyncio.sleep(5 * 60)

                if not self.running:
                    break

                # Check if connection is healthy
                if not await self._check_connection_health():
                    if self.logger:
                        self.logger.log("Connection health check failed, reconnecting...", "WARNING")
                    # Try to reconnect
                    try:
                        await self.connect()
                    except Exception as e:
                        if self.logger:
                            self.logger.log(f"Reconnection failed: {e}", "ERROR")
                        # Wait before retrying
                        await asyncio.sleep(30)
                    continue

                # Check if we need to keepalive the listen key (every 50 minutes)
                if self.listen_key and time.time() % (50 * 60) < 5 * 60:  # Within 5 minutes of 50-minute mark
                    success = await self._keepalive_listen_key()
                    if not success:
                        if self.logger:
                            self.logger.log("Listen key keepalive failed, reconnecting...", "WARNING")
                        # Try to reconnect
                        try:
                            await self.connect()
                        except Exception as e:
                            if self.logger:
                                self.logger.log(f"Reconnection failed: {e}", "ERROR")
                            # Wait before retrying
                            await asyncio.sleep(30)

            except Exception as e:
                if self.logger:
                    self.logger.log(f"Error in keepalive task: {e}", "ERROR")
                # Wait a bit before retrying
                await asyncio.sleep(60)

    async def connect(self):
        """Connect to Aster WebSocket."""
        try:
            # Get listen key
            self.listen_key = await self._get_listen_key()
            if not self.listen_key:
                raise Exception("Failed to get listen key")

            # Connect to WebSocket
            ws_url = f"{self.ws_url}/ws/{self.listen_key}"
            self.websocket = await websockets.connect(ws_url)
            self.running = True

            if self.logger:
                self.logger.log("Connected to Aster WebSocket with listen key", "INFO")

            # Start keepalive task
            self._keepalive_task = asyncio.create_task(self._start_keepalive_task())

            # Start listening for messages
            await self._listen()

        except Exception as e:
            if self.logger:
                self.logger.log(f"WebSocket connection error: {e}", "ERROR")
            raise

    async def _listen(self):
        """Listen for WebSocket messages."""
        try:
            async for message in self.websocket:
                if not self.running:
                    break

                # Check if this is a ping frame (websockets library handles pong automatically)
                if isinstance(message, bytes) and message == b'\x89\x00':  # Ping frame
                    self._last_ping_time = time.time()
                    if self.logger:
                        self.logger.log("Received ping frame, sending pong", "DEBUG")
                    continue

                try:
                    data = json.loads(message)
                    await self._handle_message(data)
                except json.JSONDecodeError as e:
                    if self.logger:
                        self.logger.log(f"Failed to parse WebSocket message: {e}", "ERROR")
                except Exception as e:
                    if self.logger:
                        self.logger.log(f"Error handling WebSocket message: {e}", "ERROR")

        except websockets.exceptions.ConnectionClosed:
            if self.logger:
                self.logger.log("WebSocket connection closed", "WARNING")
        except Exception as e:
            if self.logger:
                self.logger.log(f"WebSocket listen error: {e}", "ERROR")

    async def _handle_message(self, data: Dict[str, Any]):
        """Handle incoming WebSocket messages."""
        try:
            event_type = data.get('e', '')

            if event_type == 'ORDER_TRADE_UPDATE':
                await self._handle_order_update(data)
            elif event_type == 'listenKeyExpired':
                if self.logger:
                    self.logger.log("Listen key expired, reconnecting...", "WARNING")
                # Reconnect with new listen key
                await self.connect()
            else:
                if self.logger:
                    self.logger.log(f"Unknown WebSocket message: {data}", "DEBUG")

        except Exception as e:
            if self.logger:
                self.logger.log(f"Error handling WebSocket message: {e}", "ERROR")

    async def _handle_order_update(self, order_data: Dict[str, Any]):
        """Handle order update messages."""
        try:
            order_info = order_data.get('o', {})

            order_id = order_info.get('i', '')
            symbol = order_info.get('s', '')
            side = order_info.get('S', '')
            quantity = order_info.get('q', '0')
            price = order_info.get('p', '0')
            executed_qty = order_info.get('z', '0')
            status = order_info.get('X', '')

            # Map status
            status_map = {
                'NEW': 'OPEN',
                'PARTIALLY_FILLED': 'PARTIALLY_FILLED',
                'FILLED': 'FILLED',
                'CANCELED': 'CANCELED',
                'REJECTED': 'REJECTED',
                'EXPIRED': 'EXPIRED'
            }
            mapped_status = status_map.get(status, status)

            # Call the order update callback if it exists
            if hasattr(self, 'order_update_callback') and self.order_update_callback:
                if side.lower() == self.config.close_order_side:
                    order_type = "CLOSE"
                else:
                    order_type = "OPEN"

                await self.order_update_callback({
                    'order_id': order_id,
                    'side': side.lower(),
                    'order_type': order_type,
                    'status': mapped_status,
                    'size': quantity,
                    'price': price,
                    'contract_id': symbol,
                    'filled_size': executed_qty
                })

        except Exception as e:
            if self.logger:
                self.logger.log(f"Error handling order update: {e}", "ERROR")

    async def disconnect(self):
        """Disconnect from WebSocket."""
        self.running = False

        # Cancel keepalive task
        if self._keepalive_task and not self._keepalive_task.done():
            self._keepalive_task.cancel()
            try:
                await self._keepalive_task
            except asyncio.CancelledError:
                pass

        if self.websocket:
            await self.websocket.close()
            if self.logger:
                self.logger.log("WebSocket disconnected", "INFO")

    def set_logger(self, logger):
        """Set the logger instance."""
        self.logger = logger


class AsterClient(BaseExchangeClient):
    """Aster exchange client implementation."""

    def __init__(self, config: Dict[str, Any]):
        """Initialize Aster client."""
        super().__init__(config)

        # Aster credentials from environment
        self.api_key = os.getenv('ASTER_API_KEY')
        self.secret_key = os.getenv('ASTER_SECRET_KEY')
        self.base_url = 'https://fapi.asterdex.com'

        if not self.api_key or not self.secret_key:
            raise ValueError(
                "ASTER_API_KEY and ASTER_SECRET_KEY must be set in environment variables"
            )

        # Initialize logger early
        self.logger = TradingLogger(exchange="aster", ticker=self.config.ticker, log_to_console=False)
        self._order_update_handler = None

    @staticmethod
    def normalize_symbol(ticker: str) -> str:
        """Normalize ticker to Aster's trading symbol format - ä½¿ç”¨ç»Ÿä¸€çš„normalize_symbol"""
        from .base import normalize_symbol as base_normalize_symbol
        return base_normalize_symbol(ticker, "USDT")

    @staticmethod
    async def resolve_contract(ticker: str, api_key: str, secret_key: str) -> Tuple[str, Decimal]:
        """Resolve contract ID and tick size for a ticker."""
        ticker = ticker.upper()
        normalized_symbol = AsterClient.normalize_symbol(ticker)
        
        try:
            # Create temporary client for contract resolution
            temp_config = {
                'ticker': ticker,
                'contract_id': '',
                'tick_size': Decimal(0),
                'quantity': Decimal(0.001),
                'take_profit': 0.02,
                'direction': 'buy',
                'max_orders': 40,
                'wait_time': 450,
                'exchange': 'aster',
                'grid_step': 0,
                'stop_price': -1,
                'pause_price': -1,
                'boost_mode': False
            }
            
            temp_client = AsterClient(temp_config)
            temp_client.api_key = api_key
            temp_client.secret_key = secret_key
            
            contract_id, tick_size = await temp_client.get_contract_attributes()
            return contract_id, tick_size
            
        except Exception as e:
            raise ValueError(f"Failed to resolve contract for {ticker}: {e}")

    def _validate_config(self) -> None:
        """Validate Aster configuration."""
        required_env_vars = ['ASTER_API_KEY', 'ASTER_SECRET_KEY']
        missing_vars = [var for var in required_env_vars if not os.getenv(var)]
        if missing_vars:
            raise ValueError(f"Missing required environment variables: {missing_vars}")

    def _generate_signature(self, params: Dict[str, Any]) -> str:
        """Generate HMAC SHA256 signature for Aster API authentication."""
        # Use urlencode to properly format the query string
        query_string = urlencode(params)

        # Generate HMAC SHA256 signature
        signature = hmac.new(
            self.secret_key.encode('utf-8'),
            query_string.encode('utf-8'),
            hashlib.sha256
        ).hexdigest()

        return signature

    async def _make_request(
        self, method: str, endpoint: str, params: Dict[str, Any] = None, data: Dict[str, Any] = None
    ) -> Dict[str, Any]:
        """Make authenticated request to Aster API."""
        if params is None:
            params = {}
        if data is None:
            data = {}

        # Add timestamp and recvWindow
        timestamp = int(time.time() * 1000)
        params['timestamp'] = timestamp
        params['recvWindow'] = 5000

        url = f"{self.base_url}{endpoint}"
        headers = {
            'X-MBX-APIKEY': self.api_key,
            'Content-Type': 'application/x-www-form-urlencoded'
        }

        async with aiohttp.ClientSession() as session:
            if method.upper() == 'GET':
                # For GET requests, signature is based on query parameters only
                signature = self._generate_signature(params)
                params['signature'] = signature

                async with session.get(url, params=params, headers=headers) as response:
                    result = await response.json()
                    if response.status != 200:
                        raise Exception(f"API request failed: {result}")
                    return result
            elif method.upper() == 'POST':
                # For POST requests, signature must include both query string and request body
                # According to Aster API docs: totalParams = queryString + requestBody
                all_params = {**params, **data}
                signature = self._generate_signature(all_params)
                all_params['signature'] = signature

                async with session.post(url, data=all_params, headers=headers) as response:
                    result = await response.json()
                    if response.status != 200:
                        raise Exception(f"API request failed: {result}")
                    return result
            elif method.upper() == 'DELETE':
                # For DELETE requests, signature is based on query parameters only
                signature = self._generate_signature(params)
                params['signature'] = signature

                async with session.delete(url, params=params, headers=headers) as response:
                    result = await response.json()
                    if response.status != 200:
                        raise Exception(f"API request failed: {result}")
                    return result

    async def connect(self) -> None:
        """Connect to Aster WebSocket."""
        # æ£€æŸ¥æ˜¯å¦åœ¨é¢„æ£€æ¨¡å¼ï¼ˆé€šè¿‡ç¯å¢ƒå˜é‡æˆ–é…ç½®ï¼‰
        import os
        if os.getenv('NO_WEBSOCKET', 'false').lower() == 'true':
            self.logger.log("é¢„æ£€æ¨¡å¼ï¼šè·³è¿‡WebSocketè¿æ¥ï¼Œä»…ä½¿ç”¨REST API", "INFO")
            return
        
        # Initialize WebSocket manager
        self.ws_manager = AsterWebSocketManager(
            config=self.config,
            api_key=self.api_key,
            secret_key=self.secret_key,
            order_update_callback=self._handle_websocket_order_update
        )

        # Set logger for WebSocket manager
        self.ws_manager.set_logger(self.logger)

        try:
            # Start WebSocket connection in background task
            asyncio.create_task(self.ws_manager.connect())
            # Wait a moment for connection to establish
            await asyncio.sleep(2)
        except Exception as e:
            self.logger.log(f"Error connecting to Aster WebSocket: {e}", "ERROR")
            raise

    async def disconnect(self) -> None:
        """Disconnect from Aster."""
        try:
            if hasattr(self, 'ws_manager') and self.ws_manager:
                await self.ws_manager.disconnect()
        except Exception as e:
            self.logger.log(f"Error during Aster disconnect: {e}", "ERROR")

    def get_exchange_name(self) -> str:
        """Get the exchange name."""
        return "aster"

    def setup_order_update_handler(self, handler) -> None:
        """Setup order update handler for WebSocket."""
        self._order_update_handler = handler

    async def _handle_websocket_order_update(self, order_data: Dict[str, Any]):
        """Handle order updates from WebSocket."""
        try:
            if self._order_update_handler:
                self._order_update_handler(order_data)
        except Exception as e:
            self.logger.log(f"Error handling WebSocket order update: {e}", "ERROR")

    @query_retry(default_return=(0, 0))
    async def fetch_bbo_prices(self, contract_id: str) -> Tuple[Decimal, Decimal]:
        """Fetch best bid and ask prices from Aster."""
        try:
            # Use unified normalize_symbol for API calls
            normalized_symbol = normalize_symbol(contract_id)
            result = await self._make_request('GET', '/fapi/v1/ticker/bookTicker', {'symbol': normalized_symbol})

            best_bid = Decimal(result.get('bidPrice', 0))
            best_ask = Decimal(result.get('askPrice', 0))

            return best_bid, best_ask
        except Exception as e:
            if "Invalid symbol" in str(e):
                raise ExchangeSymbolError(f"Invalid symbol: {contract_id}", contract_id)
            raise

    async def get_order_price(self, direction: str) -> Decimal:
        """Get the price of an order with Aster using official SDK."""
        best_bid, best_ask = await self.fetch_bbo_prices(self.config.contract_id)
        if best_bid <= 0 or best_ask <= 0:
            self.logger.log("Invalid bid/ask prices", "ERROR")
            raise ValueError("Invalid bid/ask prices")

        if direction == 'buy':
            # For buy orders, place slightly below best ask to ensure execution
            order_price = best_ask - self.config.tick_size
        else:
            # For sell orders, place slightly above best bid to ensure execution
            order_price = best_bid + self.config.tick_size
        return order_price

    async def place_open_order(self, contract_id: str, quantity: Decimal, direction: str) -> OrderResult:
        """Place an open order with Aster."""
        attempt = 0
        while True:
            attempt += 1
            if attempt % 5 == 0:
                self.logger.log(f"[OPEN] Attempt {attempt} to place order", "INFO")
                active_orders = await self.get_active_orders(contract_id)
                active_open_orders = 0
                for order in active_orders:
                    if order.side == self.config.direction:
                        active_open_orders += 1
                if active_open_orders > 1:
                    self.logger.log(f"[OPEN] ERROR: Active open orders abnormal: {active_open_orders}", "ERROR")
                    raise Exception(f"[OPEN] ERROR: Active open orders abnormal: {active_open_orders}")

            best_bid, best_ask = await self.fetch_bbo_prices(contract_id)

            if best_bid <= 0 or best_ask <= 0:
                return OrderResult(success=False, error_message='Invalid bid/ask prices')

            # Determine order side and price
            if direction == 'buy':
                # For buy orders, place slightly below best ask to ensure execution
                price = best_ask - self.config.tick_size
            elif direction == 'sell':
                # For sell orders, place slightly above best bid to ensure execution
                price = best_bid + self.config.tick_size
            else:
                raise Exception(f"[OPEN] Invalid direction: {direction}")

            # Place the order
            normalized_symbol = self.normalize_symbol(contract_id)
            order_data = {
                'symbol': normalized_symbol,
                'side': direction.upper(),
                'type': 'LIMIT',
                'quantity': str(quantity),
                'price': str(price),
                'timeInForce': 'GTX'  # GTX is Good Till Crossing (Post Only)
            }

            result = await self._make_request('POST', '/fapi/v1/order', data=order_data)
            order_status = result.get('status', '')
            order_id = result.get('orderId', '')

            start_time = time.time()
            while order_status == 'NEW' and time.time() - start_time < 2:
                await asyncio.sleep(0.1)
                order_info = await self.get_order_info(order_id)
                if order_info is not None:
                    order_status = order_info.status

            if order_status in ['NEW', 'PARTIALLY_FILLED']:
                return OrderResult(success=True, order_id=order_id, side=direction, size=quantity, price=price, status='OPEN')
            elif order_status == 'FILLED':
                return OrderResult(success=True, order_id=order_id, side=direction, size=quantity, price=price, status='FILLED')
            elif order_status == 'EXPIRED':
                continue
            else:
                return OrderResult(success=False, error_message='Unknown order status: ' + order_status)

    async def _get_active_close_orders(self, contract_id: str) -> int:
        """Get active close orders for a contract using official SDK."""
        active_orders = await self.get_active_orders(contract_id)
        active_close_orders = 0
        for order in active_orders:
            if order.side == self.config.close_order_side:
                active_close_orders += 1
        return active_close_orders

    async def place_close_order(self, contract_id: str, quantity: Decimal, price: Decimal, side: str, reduce_only: bool = False, post_only: bool = False) -> OrderResult:
        """Place a close order with Aster."""
        attempt = 0
        active_close_orders = await self._get_active_close_orders(contract_id)
        while True:
            attempt += 1
            if attempt % 5 == 0:
                self.logger.log(f"[CLOSE] Attempt {attempt} to place order", "INFO")
                current_close_orders = await self._get_active_close_orders(contract_id)

                if current_close_orders - active_close_orders > 1:
                    self.logger.log(f"[CLOSE] ERROR: Active close orders abnormal: "
                                    f"{active_close_orders}, {current_close_orders}", "ERROR")
                    raise Exception(f"[CLOSE] ERROR: Active close orders abnormal: "
                                    f"{active_close_orders}, {current_close_orders}")
                else:
                    active_close_orders = current_close_orders
            # Get current market prices to adjust order price if needed
            best_bid, best_ask = await self.fetch_bbo_prices(contract_id)

            if best_bid <= 0 or best_ask <= 0:
                return OrderResult(success=False, error_message='No bid/ask data available')

            # Adjust order price based on market conditions and side
            adjusted_price = price
            if side.lower() == 'sell':
                order_side = 'SELL'
                # For sell orders, ensure price is above best bid to be a maker order
                if price <= best_bid:
                    adjusted_price = best_bid + self.config.tick_size
            elif side.lower() == 'buy':
                order_side = 'BUY'
                # For buy orders, ensure price is below best ask to be a maker order
                if price >= best_ask:
                    adjusted_price = best_ask - self.config.tick_size

            adjusted_price = self.round_to_tick(adjusted_price)

            # Place the order
            normalized_symbol = self.normalize_symbol(contract_id)
            order_data = {
                'symbol': normalized_symbol,
                'side': order_side,
                'type': 'LIMIT',
                'quantity': str(quantity),
                'price': str(adjusted_price),
                'timeInForce': 'GTX'  # GTX is Good Till Crossing (Post Only)
            }
            
            # ğŸ”§ å…³é”®ä¿®å¤ï¼šæ·»åŠ reduceOnlyå‚æ•°
            if reduce_only:
                order_data['reduceOnly'] = True

            result = await self._make_request('POST', '/fapi/v1/order', data=order_data)
            order_status = result.get('status', '')
            order_id = result.get('orderId', '')

            start_time = time.time()
            while order_status == 'NEW' and time.time() - start_time < 2:
                await asyncio.sleep(0.1)
                order_info = await self.get_order_info(order_id)
                if order_info is not None:
                    order_status = order_info.status

            if order_status in ['NEW', 'PARTIALLY_FILLED']:
                return OrderResult(success=True, order_id=order_id, side=order_side.lower(),
                                   size=quantity, price=adjusted_price, status='OPEN')
            elif order_status == 'FILLED':
                return OrderResult(success=True, order_id=order_id, side=order_side.lower(),
                                   size=quantity, price=adjusted_price, status='FILLED')
            elif order_status == 'EXPIRED':
                continue
            else:
                return OrderResult(success=False, error_message='Unknown order status: ' + order_status)

    async def place_market_order(self, contract_id: str, quantity: Decimal, direction: str, reduce_only: bool = False) -> OrderResult:
        """Place a market order with Aster."""
        # Validate direction
        if direction.lower() not in ['buy', 'sell']:
            return OrderResult(success=False, error_message=f'Invalid direction: {direction}')

        # Place the market order
            normalized_symbol = self.normalize_symbol(contract_id)
            order_data = {
                'symbol': normalized_symbol,
                'side': direction.upper(),
                'type': 'MARKET',
                'quantity': str(quantity)
            }
            
            # ğŸ”§ å…³é”®ä¿®å¤ï¼šæ·»åŠ reduceOnlyå‚æ•°
            if reduce_only:
                order_data['reduceOnly'] = True

        result = await self._make_request('POST', '/fapi/v1/order', data=order_data)
        order_status = result.get('status', '')
        order_id = result.get('orderId', '')

        start_time = time.time()
        while order_status != 'FILLED' and time.time() - start_time < 10:
            await asyncio.sleep(0.2)
            order_info = await self.get_order_info(order_id)
            if order_info is not None:
                order_status = order_info.status

        if order_status != 'FILLED':
            self.logger.log(f"Market order failed with status: {order_status}", "ERROR")
            sys.exit(1)
        # For market orders, we expect them to be filled immediately
        else:
            return OrderResult(
                success=True,
                order_id=order_id,
                side=direction.lower(),
                size=quantity,
                price=order_info.price,
                status='FILLED'
            )

    async def cancel_order(self, order_id: str) -> OrderResult:
        """Cancel an order with Aster."""
        try:
            normalized_symbol = self.normalize_symbol(self.config.contract_id)
            result = await self._make_request('DELETE', '/fapi/v1/order', {
                'symbol': normalized_symbol,
                'orderId': order_id
            })

            if 'orderId' in result:
                return OrderResult(success=True, filled_size=Decimal(result.get('executedQty', 0)))
            else:
                return OrderResult(success=False, error_message=result.get('msg', 'Unknown error'))

        except Exception as e:
            return OrderResult(success=False, error_message=str(e))

    @query_retry()
    async def get_order_info(self, order_id: str) -> Optional[OrderInfo]:
        """Get order information from Aster."""
        normalized_symbol = self.normalize_symbol(self.config.contract_id)
        result = await self._make_request('GET', '/fapi/v1/order', {
            'symbol': normalized_symbol,
            'orderId': order_id
        })

        order_type = result.get('type', '')
        if order_type == 'MARKET':
            price = Decimal(result.get('avgPrice', 0))
        else:
            price = Decimal(result.get('price', 0))

        if 'orderId' in result:
            return OrderInfo(
                order_id=str(result['orderId']),
                side=result.get('side', '').lower(),
                size=Decimal(result.get('origQty', 0)),
                price=price,
                status=result.get('status', ''),
                filled_size=Decimal(result.get('executedQty', 0)),
                remaining_size=Decimal(result.get('origQty', 0)) - Decimal(result.get('executedQty', 0))
            )
        return None

    @query_retry(default_return=[])
    async def get_active_orders(self, contract_id: str) -> List[OrderInfo]:
        """Get active orders for a contract from Aster."""
        try:
            # Use unified normalize_symbol for API calls
            normalized_symbol = normalize_symbol(contract_id)
            result = await self._make_request('GET', '/fapi/v1/openOrders', {'symbol': normalized_symbol})

            orders = []
            for order in result:
                orders.append(OrderInfo(
                    order_id=str(order['orderId']),
                    side=order.get('side', '').lower(),
                    size=Decimal(order.get('origQty', 0)) - Decimal(order.get('executedQty', 0)),
                    price=Decimal(order.get('price', 0)),
                    status=order.get('status', ''),
                    filled_size=Decimal(order.get('executedQty', 0)),
                    remaining_size=Decimal(order.get('origQty', 0)) - Decimal(order.get('executedQty', 0))
                ))

            return orders
        except Exception as e:
            if "Invalid symbol" in str(e):
                raise ExchangeSymbolError(f"Invalid symbol: {contract_id}", contract_id)
            raise

    @query_retry(reraise=True)
    async def get_account_positions(self) -> Decimal:
        """Get account positions from Aster."""
        try:
            # Use unified normalize_symbol for API calls
            symbol_to_use = self.config.contract_id or self.config.ticker
            normalized_symbol = normalize_symbol(symbol_to_use)
            result = await self._make_request('GET', '/fapi/v2/positionRisk', {'symbol': normalized_symbol})

            for position in result:
                if position.get('symbol') == normalized_symbol:
                    position_amt = Decimal(position.get('positionAmt', 0))  # ç§»é™¤ abs() ä¿ç•™æ­£è´Ÿå·
                    return position_amt

            return Decimal(0)
        except Exception as e:
            if "Invalid symbol" in str(e):
                raise ExchangeSymbolError(f"Invalid symbol: {symbol_to_use}", symbol_to_use)
            raise

    async def get_contract_attributes(self) -> Tuple[str, Decimal]:
        """Get contract ID and tick size for a ticker."""
        ticker = self.config.ticker
        if len(ticker) == 0:
            self.logger.log("Ticker is empty", "ERROR")
            raise ValueError("Ticker is empty")

        try:
            # Normalize ticker to get the correct symbol
            normalized_symbol = self.normalize_symbol(ticker)
            result = await self._make_request('GET', '/fapi/v1/exchangeInfo')

            for symbol_info in result['symbols']:
                if (symbol_info.get('status') == 'TRADING' and
                        symbol_info.get('symbol') == normalized_symbol):

                    self.config.contract_id = symbol_info.get('symbol', '')

                    # Get tick size from filters
                    for filter_info in symbol_info.get('filters', []):
                        if filter_info.get('filterType') == 'PRICE_FILTER':
                            self.config.tick_size = Decimal(filter_info['tickSize'].strip('0'))
                            break

                    # Get minimum quantity
                    min_quantity = Decimal(0)
                    for filter_info in symbol_info.get('filters', []):
                        if filter_info.get('filterType') == 'LOT_SIZE':
                            min_quantity = Decimal(filter_info.get('minQty', 0))
                            break

                    if self.config.quantity < min_quantity:
                        self.logger.log(
                            f"Order quantity is less than min quantity: "
                            f"{self.config.quantity} < {min_quantity}", "ERROR"
                        )
                        raise ValueError(
                            f"Order quantity is less than min quantity: "
                            f"{self.config.quantity} < {min_quantity}"
                        )

                    if self.config.tick_size == 0:
                        self.logger.log("Failed to get tick size for ticker", "ERROR")
                        raise ValueError("Failed to get tick size for ticker")

                    return self.config.contract_id, self.config.tick_size

            # Invalid symbol - ç«‹å³fail-fast
            self.logger.log(f"Invalid symbol: {normalized_symbol}", "ERROR")
            raise ExchangeSymbolError(f"Invalid symbol: {normalized_symbol}")

        except ExchangeSymbolError:
            # é‡æ–°æŠ›å‡ºExchangeSymbolErrorï¼Œä¸åŒ…è£…
            raise
        except Exception as e:
            self.logger.log(f"Error getting contract attributes: {e}", "ERROR")
            raise
    
    async def get_position_for_symbol(self, symbol: str) -> Decimal:
        """è·å–æŒ‡å®šsymbolçš„å‡€ä»“ä½"""
        try:
            # å…ˆè§„èŒƒåŒ–symbol
            normalized_symbol = normalize_symbol(symbol)
            
            # æŸ¥è¯¢ä»“ä½ä¿¡æ¯
            result = await self._make_request('GET', '/fapi/v2/positionRisk', {'symbol': normalized_symbol})
            
            for position in result:
                if position.get('symbol') == normalized_symbol:
                    position_amt = Decimal(position.get('positionAmt', 0))
                    return position_amt
            
            # å¦‚æœæ²¡æœ‰æ‰¾åˆ°è¯¥symbolçš„ä»“ä½ï¼Œè¿”å›0
            return Decimal(0)
            
        except Exception as e:
            if "Invalid symbol" in str(e):
                raise ExchangeSymbolError(f"Invalid symbol: {symbol}", symbol)
            raise
    
    async def get_open_orders_for_symbol(self, symbol: str) -> List[Any]:
        """è·å–æŒ‡å®šsymbolçš„æ´»åŠ¨è®¢å•"""
        try:
            # å…ˆè§„èŒƒåŒ–symbol
            normalized_symbol = normalize_symbol(symbol)
            
            # æŸ¥è¯¢æ´»åŠ¨è®¢å•
            result = await self._make_request('GET', '/fapi/v1/openOrders', {'symbol': normalized_symbol})
            
            # è¿‡æ»¤å‡ºåŒ¹é…çš„è®¢å•
            matching_orders = []
            for order in result:
                if order.get('symbol') == normalized_symbol:
                    matching_orders.append(order)
            
            return matching_orders
            
        except Exception as e:
            if "Invalid symbol" in str(e):
                raise ExchangeSymbolError(f"Invalid symbol: {symbol}", symbol)
            raise
    
    async def cancel_all_orders(self, symbol: str) -> bool:
        """å–æ¶ˆæŒ‡å®šsymbolçš„æ‰€æœ‰è®¢å•"""
        try:
            # å…ˆè§„èŒƒåŒ–symbol
            normalized_symbol = normalize_symbol(symbol)
            
            # å–æ¶ˆæ‰€æœ‰è®¢å•
            result = await self._make_request('DELETE', '/fapi/v1/allOpenOrders', {'symbol': normalized_symbol})
            return True
            
        except Exception as e:
            if "Invalid symbol" in str(e):
                raise ExchangeSymbolError(f"Invalid symbol: {symbol}", symbol)
            raise

    async def place_stop_market_order(self, contract_id: str, quantity: Decimal, 
                                    trigger_price: Decimal, side: str) -> OrderResult:
        """Aster stop market order implementation."""
        try:
            normalized_symbol = self.normalize_symbol(contract_id)
            order_data = {
                'symbol': normalized_symbol,
                'side': side.upper(),
                'type': 'STOP_MARKET',
                'quantity': str(quantity),
                'stopPrice': str(trigger_price)
            }
            
            result = await self._make_request('POST', '/fapi/v1/order', data=order_data)
            
            if result.get('orderId'):
                return OrderResult(
                    success=True,
                    order_id=result.get('orderId'),
                    side=side,
                    size=quantity,
                    price=trigger_price,
                    status='OPEN'
                )
            else:
                return OrderResult(success=False, error_message=result.get('msg', 'Unknown error'))
                
        except Exception as e:
            return OrderResult(success=False, error_message=str(e))

    async def place_market_order(self, contract_id: str, quantity: Decimal, 
                                side: str, reduce_only: bool = False) -> OrderResult:
        """Aster market order implementation with precision validation."""
        try:
            # 1. æ ‡å‡†åŒ–symbol
            normalized_symbol = self.normalize_symbol(contract_id)
            
            # 2. è·å–åˆçº¦ä¿¡æ¯è¿›è¡Œç²¾åº¦æ ¡éªŒ
            try:
                contract_info = await self._make_request('GET', '/fapi/v1/exchangeInfo')
                symbol_info = None
                for symbol in contract_info.get('symbols', []):
                    if symbol.get('symbol') == normalized_symbol:
                        symbol_info = symbol
                        break
                
                if not symbol_info:
                    return OrderResult(success=False, error_message=f"Symbol {normalized_symbol} not found")
                
                # 3. ç²¾åº¦æ ¡éªŒ
                filters = symbol_info.get('filters', [])
                min_qty = None
                step_size = None
                
                for filter_info in filters:
                    if filter_info.get('filterType') == 'LOT_SIZE':
                        min_qty = Decimal(filter_info.get('minQty', '0'))
                        step_size = Decimal(filter_info.get('stepSize', '0'))
                        break
                
                # 3. æœ€å°æ•°é‡æ ¡éªŒå’Œè°ƒæ•´
                if min_qty and quantity < min_qty:
                    import sys
                    print(f"WARNING: quantity {quantity} < minQty {min_qty}, æ®‹å·® {quantity} éœ€è¦äººå·¥å¹²é¢„æˆ–ç´¯ç§¯åˆ°ä¸‹æ¬¡", file=sys.stderr)
                    # å¯¹äºå¸‚ä»·å¹³ä»“ï¼Œå¦‚æœæ•°é‡ä¸è¶³æœ€å°é‡ï¼Œç›´æ¥è¿”å›æˆåŠŸï¼ˆè§†ä¸ºå·²å¹³ä»“ï¼‰
                    if reduce_only:
                        return OrderResult(
                            success=True,
                            order_id="residual_too_small",
                            side=side,
                            size=quantity,
                            price=Decimal('0'),
                            status='FILLED',
                            filled_size=quantity
                        )
                    else:
                        return OrderResult(success=False, error_message=f"min_qty_violation: quantity {quantity} < minQty {min_qty}")
                
                # 4. æ­¥é•¿æ ¡éªŒå’Œè°ƒæ•´
                if step_size and step_size > 0:
                    # è½¬æ¢ä¸ºDecimalè¿›è¡Œç²¾ç¡®è®¡ç®—
                    quantity_decimal = Decimal(str(quantity))
                    step_size_decimal = Decimal(str(step_size))
                    remainder = quantity_decimal % step_size_decimal
                    if remainder != 0:
                        # è°ƒæ•´åˆ°æœ€è¿‘çš„æ­¥é•¿
                        adjusted_quantity = (quantity_decimal // step_size_decimal) * step_size_decimal
                        if adjusted_quantity < min_qty:
                            import sys
                            print(f"WARNING: è°ƒæ•´åæ•°é‡ {adjusted_quantity} < minQty {min_qty}, æ®‹å·® {quantity - adjusted_quantity} éœ€è¦äººå·¥å¹²é¢„", file=sys.stderr)
                            # å¯¹äºå¸‚ä»·å¹³ä»“ï¼Œå¦‚æœè°ƒæ•´åä»ä¸è¶³æœ€å°é‡ï¼Œç›´æ¥è¿”å›æˆåŠŸ
                            if reduce_only:
                                return OrderResult(
                                    success=True,
                                    order_id="residual_too_small",
                                    side=side,
                                    size=quantity,
                                    price=Decimal('0'),
                                    status='FILLED',
                                    filled_size=quantity
                                )
                            else:
                                return OrderResult(success=False, error_message=f"min_qty_violation after step adjustment")
                        quantity = float(adjusted_quantity)
                
            except Exception as e:
                # å¦‚æœè·å–åˆçº¦ä¿¡æ¯å¤±è´¥ï¼Œç»§ç»­æ‰§è¡Œä½†è®°å½•è­¦å‘Š
                import sys
                print(f"WARNING: Failed to get contract info for precision validation: {e}", file=sys.stderr)
            
            # 5. æ„å»ºè®¢å•æ•°æ®
            order_data = {
                'symbol': normalized_symbol,
                'side': side.upper(),
                'type': 'MARKET',
                'quantity': str(quantity)
            }
            
            # 6. æ·»åŠ reduceOnlyå‚æ•°
            if reduce_only:
                order_data['reduceOnly'] = True
            
            # 7. å‘é€è®¢å•ï¼ˆå¸¦é‡è¯•ç­–ç•¥ï¼‰
            max_retries = 5
            base_delay = 1.0
            
            for attempt in range(max_retries):
                try:
                    result = await self._make_request('POST', '/fapi/v1/order', data=order_data)
                    
                    if result.get('orderId'):
                        return OrderResult(
                            success=True,
                            order_id=str(result.get('orderId')),
                            side=side,
                            size=quantity,
                            price=Decimal('0'),  # Market order price is 0
                            status='FILLED',
                            filled_size=quantity
                        )
                    else:
                        error_msg = result.get('msg', 'Unknown error')
                        # æ£€æŸ¥æ˜¯å¦æ˜¯å¯é‡è¯•çš„é”™è¯¯
                        if attempt < max_retries - 1 and any(keyword in error_msg.lower() for keyword in ['timeout', 'network', 'rate limit', 'busy']):
                            delay = base_delay * (2 ** attempt)  # æŒ‡æ•°é€€é¿
                            import sys
                            print(f"WARNING: ä¸‹å•å¤±è´¥ (å°è¯• {attempt + 1}/{max_retries}): {error_msg}, {delay:.1f}såé‡è¯•", file=sys.stderr)
                            import asyncio
                            await asyncio.sleep(delay)
                            continue
                        else:
                            import sys
                            print(f"ERROR: ä¸‹å•å¤±è´¥ (å°è¯• {attempt + 1}/{max_retries}): {error_msg}", file=sys.stderr)
                            return OrderResult(success=False, error_message=error_msg)
                            
                except Exception as e:
                    if attempt < max_retries - 1:
                        delay = base_delay * (2 ** attempt)
                        import sys
                        print(f"WARNING: ç½‘ç»œå¼‚å¸¸ (å°è¯• {attempt + 1}/{max_retries}): {e}, {delay:.1f}såé‡è¯•", file=sys.stderr)
                        import asyncio
                        await asyncio.sleep(delay)
                        continue
                    else:
                        import sys
                        print(f"ERROR: ç½‘ç»œå¼‚å¸¸ (å°è¯• {attempt + 1}/{max_retries}): {e}", file=sys.stderr)
                        return OrderResult(success=False, error_message=str(e))
            
            # æ‰€æœ‰é‡è¯•éƒ½å¤±è´¥äº†
            return OrderResult(success=False, error_message="æ‰€æœ‰é‡è¯•å°è¯•éƒ½å¤±è´¥äº†")
                
        except Exception as e:
            return OrderResult(success=False, error_message=str(e))
    
    async def cancel_all_open_orders(self, contract_id: str) -> bool:
        """å–æ¶ˆæŒ‡å®šåˆçº¦çš„æ‰€æœ‰æ´»åŠ¨è®¢å•"""
        try:
            # 1. æ ‡å‡†åŒ–symbol
            normalized_symbol = self.normalize_symbol(contract_id)
            
            # 2. å–æ¶ˆæ‰€æœ‰æ´»åŠ¨è®¢å•
            result = await self._make_request('DELETE', '/fapi/v1/allOpenOrders', {'symbol': normalized_symbol})
            
            # 3. æ£€æŸ¥ç»“æœ
            if result.get('code') == 200 or result.get('msg') == 'success' or 'orderId' in result:
                return True
            else:
                # å³ä½¿APIè¿”å›é”™è¯¯ï¼Œä¹Ÿå¯èƒ½éƒ¨åˆ†è®¢å•è¢«å–æ¶ˆ
                # æ£€æŸ¥æ˜¯å¦è¿˜æœ‰æ´»åŠ¨è®¢å•
                try:
                    open_orders = await self.get_open_orders_for_symbol(normalized_symbol)
                    return len(open_orders) == 0
                except:
                    # å¦‚æœæ— æ³•æ£€æŸ¥ï¼Œå‡è®¾æ“ä½œæˆåŠŸ
                    return True
                    
        except Exception as e:
            # è®°å½•é”™è¯¯ä½†è¿”å›False
            import sys
            print(f"WARNING: cancel_all_open_orders failed: {e}", file=sys.stderr)
            return False
    
    async def cancel_all_orders_deep(self, symbol: str) -> int:
        """æ·±åº¦æ’¤å•ï¼šé€ç±»å–æ¶ˆ+é‡è¯•+æ”¶å°¾å¤æ ¸ï¼Œæœ€ç»ˆremaining==0"""
        try:
            # 1. æ ‡å‡†åŒ–symbol
            normalized_symbol = self.normalize_symbol(symbol)
            
            # 2. è·å–æ‰€æœ‰è®¢å•ç±»å‹
            orders_info = await self.list_open_orders_all(normalized_symbol)
            total_orders = orders_info.get("total", 0)
            
            if total_orders == 0:
                return 0
            
            # 3. é€ç±»å–æ¶ˆè®¢å•
            max_retries = 3
            for attempt in range(max_retries):
                try:
                    # å–æ¶ˆæ‰€æœ‰æ´»åŠ¨è®¢å•
                    result = await self._make_request('DELETE', '/fapi/v1/allOpenOrders', {'symbol': normalized_symbol})
                    
                    # ç­‰å¾…1ç§’è®©è®¢å•çŠ¶æ€æ›´æ–°
                    import asyncio
                    await asyncio.sleep(1)
                    
                    # æ£€æŸ¥å‰©ä½™è®¢å•
                    remaining_orders = await self.get_open_orders_for_symbol(normalized_symbol)
                    remaining = len(remaining_orders)
                    
                    if remaining == 0:
                        return 0
                    
                    # å¦‚æœè¿˜æœ‰å‰©ä½™è®¢å•ï¼Œè®°å½•å¹¶é‡è¯•
                    import sys
                    print(f"WARNING: Cancel attempt {attempt + 1}/{max_retries}, {remaining} orders remaining", file=sys.stderr)
                    
                except Exception as e:
                    import sys
                    print(f"WARNING: Cancel attempt {attempt + 1}/{max_retries} failed: {e}", file=sys.stderr)
                    if attempt == max_retries - 1:
                        raise e
            
            # 4. æ”¶å°¾å¤æ ¸ï¼šå¦‚æœè¿˜æœ‰å‰©ä½™è®¢å•ï¼ŒæŠ›å‡ºå¼‚å¸¸
            final_orders = await self.get_open_orders_for_symbol(normalized_symbol)
            final_remaining = len(final_orders)
            
            if final_remaining > 0:
                from exchanges.base import ExchangeError
                raise ExchangeError(f"Cancel all orders failed, {final_remaining} orders remaining after {max_retries} attempts")
            
            return 0
                
        except Exception as e:
            # ğŸ”§ ä¿®æ”¹ï¼šå¼‚å¸¸å‘ä¸ŠæŠ›ï¼Œä¸è¿”å›"0å……å¥½äºº"
            import sys
            print(f"ERROR: cancel_all_orders_deep failed: {e}", file=sys.stderr)
            raise e
    
    async def list_open_orders_all(self, symbol: str) -> dict:
        """æ·±åº¦æšä¸¾æ‰€æœ‰è®¢å•ç±»å‹"""
        try:
            # 1. æ ‡å‡†åŒ–symbol
            normalized_symbol = self.normalize_symbol(symbol)
            
            # 2. è·å–æ‰€æœ‰æ´»åŠ¨è®¢å•
            open_orders = await self.get_open_orders_for_symbol(normalized_symbol)
            
            # 3. æŒ‰ç±»å‹åˆ†ç±»
            by_type = {
                "normal": 0,
                "conditional": 0,
                "algo": 0,
                "position_attached": 0
            }
            
            for order in open_orders:
                order_type = order.get('type', 'normal')
                if order_type in ['STOP', 'STOP_MARKET', 'TAKE_PROFIT', 'TAKE_PROFIT_MARKET']:
                    by_type["conditional"] += 1
                elif order_type in ['TRAILING_STOP_MARKET']:
                    by_type["algo"] += 1
                elif order.get('reduceOnly', False):
                    by_type["position_attached"] += 1
                else:
                    by_type["normal"] += 1
            
            total = sum(by_type.values())
            
            return {
                "total": total,
                "by_type": by_type
            }
            
        except Exception as e:
            # ğŸ”§ ä¿®æ”¹ï¼šå¼‚å¸¸å‘ä¸ŠæŠ›ï¼Œä¸è¿”å›"0å……å¥½äºº"
            import sys
            print(f"ERROR: list_open_orders_all failed: {e}", file=sys.stderr)
            raise e
    
    async def market_flatten(self, symbol: str) -> dict:
        """å¸‚ä»·æ¸…ä»“ï¼šreduce-onlyå¸‚ä»·å•+è½®è¯¢ç¡®è®¤pos==0"""
        try:
            # 1. æ ‡å‡†åŒ–symbol
            normalized_symbol = self.normalize_symbol(symbol)
            
            # 2. è·å–å½“å‰ä»“ä½
            position = await self.get_position_for_symbol(normalized_symbol)
            
            # 3. æ£€æŸ¥æ˜¯å¦å·²ç»ä¸º0
            epsilon = 1e-9
            if abs(position) < epsilon:
                return {
                    "ok": True,
                    "flattened": True,
                    "skipped": True,
                    "symbol": normalized_symbol
                }
            
            # 4. è·å–åˆçº¦ä¿¡æ¯è¿›è¡Œç²¾åº¦å¤„ç†
            try:
                exchange_info = await self._make_request('GET', '/fapi/v1/exchangeInfo')
                min_qty = None
                step_size = None
                
                for symbol_info in exchange_info.get('symbols', []):
                    if symbol_info.get('symbol') == normalized_symbol:
                        for filter_info in symbol_info.get('filters', []):
                            if filter_info.get('filterType') == 'LOT_SIZE':
                                min_qty = Decimal(filter_info.get('minQty', '0'))
                                step_size = Decimal(filter_info.get('stepSize', '0'))
                                break
                        break
            except Exception as e:
                import sys
                print(f"WARNING: Failed to get contract info for precision: {e}", file=sys.stderr)
                min_qty = Decimal('0.001')  # é»˜è®¤æœ€å°æ•°é‡
                step_size = Decimal('0.001')  # é»˜è®¤æ­¥é•¿
            
            # 5. æŒ‰tick_size/step_sizeå–æ•´ï¼Œé˜²æ­¢å››èˆäº”å…¥æˆ0
            if step_size and step_size > 0:
                position_rounded = (abs(position) // step_size) * step_size
                if position_rounded < min_qty:
                    position_rounded = min_qty
            else:
                position_rounded = abs(position)
            
            # 6. è®¡ç®—åå‘side
            if position > 0:
                side = "sell"  # å¤šä»“éœ€è¦å–å‡º
            else:
                side = "buy"   # ç©ºä»“éœ€è¦ä¹°å…¥
            
            # 7. ä¸‹reduceOnly=Trueçš„å¸‚ä»·å•
            order_result = await self.place_market_order(
                normalized_symbol, 
                Decimal(str(position_rounded)), 
                side, 
                reduce_only=True
            )
            
            if not order_result.success:
                raise Exception(f"Market flatten order failed: {order_result.error_message}")
            
            # 8. è½®è¯¢ç¡®è®¤pos==0
            max_attempts = 10
            for attempt in range(max_attempts):
                import asyncio
                await asyncio.sleep(1)  # ç­‰å¾…1ç§’
                
                current_position = await self.get_position_for_symbol(normalized_symbol)
                if abs(current_position) <= epsilon:
                    return {
                        "ok": True,
                        "flattened": True,
                        "symbol": normalized_symbol
                    }
            
            # 9. è¶…æ—¶æ£€æŸ¥æœ€ç»ˆçŠ¶æ€
            final_position = await self.get_position_for_symbol(normalized_symbol)
            if abs(final_position) <= epsilon:
                return {
                    "ok": True,
                    "flattened": True,
                    "symbol": normalized_symbol
                }
            else:
                raise Exception(f"Market flatten timeout, position still {final_position}")
                
        except Exception as e:
            # ğŸ”§ ä¿®æ”¹ï¼šå¼‚å¸¸å‘ä¸ŠæŠ›ï¼Œä¸è¿”å›"0å……å¥½äºº"
            import sys
            print(f"ERROR: market_flatten failed: {e}", file=sys.stderr)
            raise e
[?2004h[root@VM-4-4-opencloudos perp-dex-tools]# 